* Design and graphics
** Principles of design by Dieter Rams
   <https://www.vitsoe.com/rw/about/good-design>

   #+BEGIN_QUOTE
   Back in the late 1970s, Dieter Rams was becoming increasingly concerned by
   the state of the world around him: “An impenetrable confusion of forms,
   colours and noises.”

   Aware that he was a significant contributor to that world, he asked himself
   an important question: is my design good design?

   His answer is expressed in his ten principles for good design.
   #+END_QUOTE

   - Good design is innovative :: The possibilities for innovation are not, by
        any means, exhausted. Technological development is always offering new
        opportunities for innovative design. But innovative design always
        develops in tandem with innovative technology, and can never be an end
        in itself.
   - Good design makes a product useful :: A product is bought to be used. It
        has to satisfy certain criteria, not only functional, but also
        psychological and aesthetic. Good design emphasises the usefulness of a
        product whilst disregarding anything that could possibly detract from
        it.
   - Good design is aesthetic :: The aesthetic quality of a product is integral
        to its usefulness because products we use every day affect our person
        and our well-being. But only well-executed objects can be beautiful.
   - Good design makes a product understandable :: It clarifies the product’s
        structure. Better still, it can make the product talk. At best, it is
        self-explanatory.
   - Good design is unobtrusive :: Products fulfilling a purpose are like tools.
        They are neither decorative objects nor works of art. Their design
        should therefore be both neutral and restrained, to leave room for the
        user’s self-expression.
   - Good design is honest :: It does not make a product more innovative,
        powerful or valuable than it really is. It does not attempt to
        manipulate the consumer with promises that cannot be kept.
   - Good design is long-lasting :: It avoids being fashionable and therefore
        never appears antiquated. Unlike fashionable design, it lasts many years
        – even in today’s throwaway society.
   - Good design is thorough down to the last detail :: Nothing must be
        arbitrary or left to chance. Care and accuracy in the design process
        show respect towards the user.
   - Good design is environmentally-friendly :: Design makes an important
        contribution to the preservation of the environment. It conserves
        resources and minimises physical and visual pollution throughout the
        lifecycle of the product.
   - Good design is as little design as possible :: Less, but better – because
        it concentrates on the essential aspects, and the products are not
        burdened with non-essentials. Back to purity, back to simplicity.
** Laws of UX
   <https://lawsofux.com/>

   A collection of seventeen important things to apply in practice when you're
   doing UX work.

   - Doherty Threshold :: Productivity soars when a computer and its users
        interact at a pace (<400ms) that ensures that neither has to wait on the
        other.
   - Fitts’s Law :: The time to acquire a target is a function of the distance
                    to and size of the target.
   - Hick’s Law :: The time it takes to make a decision increases with the
                   number and complexity of choices.
   - Jakob’s Law :: Users spend most of their time on other sites. This means
                    that users prefer your site to work the same way as all the
                    other sites they already know.
   - Law of Common Region :: Elements tend to be perceived into groups if they
        are sharing an area with a clearly defined boundary.
   - Law of Prägnanz :: People will perceive and interpret ambiguous or complex
        images as the simplest form possible, because it is the interpretation
        that requires the least cognitive effort of us.
   - Law of Proximity :: Objects that are near, or proximate to each other, tend
        to be grouped together.
   - Law of Similarity :: The human eye tends to perceive similar elements in a
        design as a complete picture, shape, or group, even if those elements
        are separated.
   - Law of Uniform Connectedness :: Elements that are visually connected are
        perceived as more related than elements with no connection.
   - Miller’s Law :: The average person can only keep 7 (plus or minus 2) items
                     in their working memory.
   - Occam’s Razor :: Among competing hypotheses that predict equally well, the
                      one with the fewest assumptions should be selected.
   - Pareto Principle :: The Pareto principle states that, for many events,
        roughly 80% of the effects come from 20% of the causes.
   - Parkinson’s Law :: Any task will inflate until all of the available time is
        spent.
   - Serial Position Effect :: Users have a propensity to best remember the
        first and last items in a series.
   - Tesler’s Law :: Tesler's Law, also known as The Law of Conservation of
                     Complexity, states that for any system there is a certain
                     amount of complexity which cannot be reduced.
   - Von Restorff Effect :: The Von Restorff effect, also known as The Isolation
        Effect, predicts that when multiple similar objects are present, the one
        that differs from the rest is most likely to be remembered.
   - Zeigarnik Effect :: People remember uncompleted or interrupted tasks better
        than completed tasks.
** Little UI details by @ux_grant
   <https://mobile.twitter.com/i/moments/880688233641848832>

   A collections of little tips from @steveschoger to improve your visual design
   skills with the little details that make a big difference
** Design tips by @steveschoger
   <https://twitter.com/i/moments/994601867987619840>
** Typography vocabulary by Pablo Stanley
   <https://twitter.com/pablostanley/status/998957556721635328>
** Variable fonts
*** Initial proposal for type variations
    https://variationsguide.typenetwork.com
*** Quick intro to variable fonts by Google :ATTACH:
    :PROPERTIES:
    :Attachments: Amstelvar-Alpha-example.png
    :ID:       1A241946-18E5-463E-9520-9F360347C582
    :END:
    https://developers.google.com/web/fundamentals/design-and-ux/typography/variable-fonts/
** Think outside the database
   <https://twitter.com/steveschoger/status/997125312411570176>

   #+BEGIN_QUOTE
   Don't be afraid to "think outside the database" — your UI doesn't need to map
   one-to-one with your data's fields and values.
   #+END_QUOTE

   See more in [[Design tips by @steveschoger]].
* Engineering
** Source control
*** Git basics
    A common git workflow that teams follow is,

    - there's a main branch (usually called "master"),
    - there might be a couple more branches for specific purposes, like
      "staging" and "demo",
    - the actual work is done in feature branches, the naming conventions may
      vary,
    - delivery of the features into the main branch is done via pull-requests
      (in Github terminology) or merge-requests (Gitlab), the merge preceded by
      code review process.

    It's then up to each team member to make sure that the changes they have
    made in their feature branch can be merged into the main branch, or any
    other branch that is intended to contain the changes.

    A few principles to loosely follow here:

    - the author is responsible for keeping their feature branch up to date with
      the main (or any other target) branch,
    - the author is responsible for any potential or real merge conflict
      resolution,
    - the author submits a pull-request and picks up reviewes
    - a rule of thumb for a team of N people is to pick roughly log(N)+1
      reviewers when the stakes are high, so in a team of 8 it's usually about 3
      reviewers,
    - the reviewers only review the code quality,
    - the CI proves that code is valid by running a suite of automated tests
      against it,
    - the author makes sure that the code does what it should do, according to
      the expectations (sometimes known as acceptance criteria),
    - most important: the author of the pull-request makes sure that no changes
      that weren't intended to be introduced are going to be introduced when the
      feature branch is merged into the target branch.

    The last is tricky. How this may even happen? This usually happens through a
    series of "git merge" operations when the author merges latest changes from
    the main branch into their feature branch. This practice is generally
    acceptable but may cause a lot of stress when the team reaches a certain
    size. From author's observations, this size is 8. At this point in time,
    it's better for every team member to get to know a simple principle: one
    feature, one commit, one pull-request.
**** One feature, one commit, one pull-request
     The core idea behind this principle is that we need to have one atomic
     commit per feature. Because git allows us to change history as we wish,
     we're going to use it.

     Consider a repo. Do:

     #+BEGIN_SRC bash
     git checkout master; git pull
     git checkout -b new-feature
     #+END_SRC

     You're now in context of the new local branch, "new-feature". It's in sync
     with "master" branch. Meanwhile, your teammates work on their own features,
     too, and what happens to "master" branch is out of your control.

     So you work on a feature and you add a few commits:

     #+BEGIN_SRC bash
     git add src/pages; git commit -m '--wip--'
     # a few minutes later
     git add src/components; git commit -m '--wip-- fix stuff'
     # an hour later
     git commit -am '--wip-- y u no work ffs'
     # and finally,
     git commit -am 'add new feature'
     #+END_SRC

     Now you have four commits. Then something like this usually happens:

     #+BEGIN_SRC bash
     git commit -am 'typo fix'
     #+END_SRC

     You feel relieved and you do

     #+BEGIN_SRC bash
     git push -u origin new-feature
     #+END_SRC

     to push the branch onto remote and track it.

     So you know you are five commits into the future, compared to the "master"
     branch, and you're totally done with the feature. Time to squash it a bit.

     When you are entirely sure that you added 5 commits, you can rebase on a
     commit that came before them:

     #+BEGIN_SRC bash
     git rebase -i HEAD~5
     #+END_SRC

     You'll see your favorite text editor (or vim, if you were lazy) showing you
     the list of commits with corresponding messages:

     #+BEGIN_SRC
     pick 8c8be6b6 --wip--
     pick e50afbc4 --wip-- fix stuff
     pick dcf7e2f2 --wip-- y u no work ffs
     pick 1d270bc9 add new feature
     pick e8417e64 typo fix
     #+END_SRC

     To squash these 5 commits into one, replace "pick" with "squash" starting
     from the second one:

     #+BEGIN_SRC
     pick 8c8be6b6 --wip--
     squash e50afbc4 --wip-- fix stuff
     squash dcf7e2f2 --wip-- y u no work ffs
     squash 1d270bc9 add new feature
     squash e8417e64 typo fix
     #+END_SRC

     Save and exit. Git will ask you for a new commit message. Originally, it
     will be a multi-line comment that will include all five previously added
     commit messages. It's up to you to wipe trashy "wips" and "typo fixes" and
     replace it with something meaningful, like "Add new feature".

     After that, git will try to rebase and most likely succeed if you didn't do
     anything other than committing (no merges from other branches into your
     feature branch). Now you have just one commit.

     If you check status, you'll see that git tells you history had diverged
     (from remote branch), with 5 and 1 commits respectively. If you try now to
     push these changes by running "git push", the operation will fail because
     git won't be able to find a merge base for your newly reorganized history
     that contains one commit. Git will try to put it on top of those five that
     you just squashed, and fail. To solve, you need to force-push it onto
     remote:

     #+BEGIN_SRC bash
     git push -f
     #+END_SRC

     Because you already set upstream branch before, git doesn't have a problem
     with finding the corresponding branch on the remote. It's also chill when
     it comes to pushing to the remote branch: the argument "-f" (or its longer
     version, "--force") makes it suppress any warnings and overwrite the
     history in the remote branch. So after you did that, you'll see just one
     new commit on Github.

     Isn't it lovely? Now you know how to turn many commits into one! Now it's
     time to alter your commit in a way that its merge base is the latest commit
     from "master" branch. To do that, you need latest changes from the target
     branch (in this case, we assume the target branch and the main branch are
     all the same: "master"). Check it out and pull:

     #+BEGIN_SRC bash
     git checkout master; git pull
     #+END_SRC

     Now you need to return back to the context of your feature branch:

     #+BEGIN_SRC bash
     git checkout new-feature
     #+END_SRC

     The next step is to replace the base of "new-feature" by doing

     #+BEGIN_SRC bash
     git rebase -i master
     #+END_SRC

     You'll see familiar text in your text editor of choice (or vim, if you're a
     vim enthusiast) with the text like

     #+BEGIN_SRC
     pick 4d9b768d Add new feature
     #+END_SRC

     The main signal that things go the right way here is that you only see one
     commit in this list. You may just close the text editor and wait until git
     is done with rebasing your changes on "master" branch.

     If there are any conflicts, you'll see a message on the terminal. In this
     case, git provides enough guidance to continue. Generally, you want to
     resolve conflicts and continue rebase; repeat until the rebase is
     successfully finished. After you're done with this, don't forget to update
     the remote branch, too:

     #+BEGIN_SRC bash
     git push -f
     #+END_SRC

     This will force-push the latest history that your local branch
     "new-feature" has into the remote branch.

     Voilà, done!

     Now you can create the new pull-request, pick your favorite reviewers and
     be sure that there will be no possible merge conflicts in the next couple
     minutes until your teammate outruns you and pushes their stuff into the
     main branch.
** Put tests where sources are
   <https://twitter.com/captainsafia/status/998971250335764480>

   #+BEGIN_QUOTE
   Change your life forever by putting your test files in the same directory as
   your source code files.
   #+END_QUOTE

** BEM
   BEM stands for "block, element, modifier". It was invented in 2014 and has
   been gaining popularity since then.

   The core idea is to have flat CSS stylesheet. The "flat" here means that not
   a single CSS selector in the stylesheet exceeds one classname. So it
   transforms this:

   #+BEGIN_SRC scss
   .table {
     // table style
   }

   .table tr {
     // table row style
   }

   .table tr td {
     // table cell style
   }
   #+END_SRC

   into this:

   #+BEGIN_SRC scss
   .table {
     // table style
   }

   .table__row {
     // table row style
   }

   .table__cell {
     // table cell style
   }
   #+END_SRC

   As a result,

   - applying the same class gives the same outcome (a common analogy would be
     the concept of purity in functional programming),
   - no way the same element can be styled differently based on their parents;
     each element has the styles of its own, derived from the classname, and
   - debugging and refactoring becomes linear and easy, the estimated effort
     does not explode as the codebase grows.

   The first entity is "block". The block is defined simply as a class name and
   is given to any DOM element that is meant to be a wrapping element or a
   container of any sort:

   #+BEGIN_SRC html
   <table class="table">
   </table>
   #+END_SRC

   Here, "table" is the block.

   The second entity is "element". It's a DOM node that is a child, but not
   necessarily a direct one, of any block:

   #+BEGIN_SRC html
   <table class="table">
     <tr class="table__row"></tr>
   </table>
   #+END_SRC

   Here, "table__row" is a classname that defines an element. You can see that
   element name is divided from the block name by two underscores. This is a
   classic BEM syntax. You can invent your own syntax, although keep in mind
   that once a newbie is introduced to the codebase you're developing, they may
   know about BEM and be ready to see classic syntax but they may not easily
   grasp your custom syntax or recognize BEM behind it. So be practical!

   Now, the third and the last entity, the "modifier":

   #+BEGIN_SRC html
   <table class="table">
     <tr class="table__row"></tr>
     <tr class="table__row table__row--inactive"></tr>
   </table>
   #+END_SRC

   Here, "table__row table__row--inactive" is a class list of an element "row"
   of block "table" with modifier "inactive". Please note that a modifier isn't
   simply a predicate string (like "disabled" in Bootstrap) but a fully
   constructed class name that consists of the block, element and modifier
   itself. The reason is to avoid collisions and follow the rule that no single
   classname should be, accidentally or intentionally, applied to more than one
   semantically distinct element in the DOM tree. So we trade verbosity for
   lower risk of name collision here. Remember that CSS has one namespace and
   it's global?

   You may also see that modifier is listed along with the element itself. Using
   a modifier classname without its corresponding element classname is
   considered against the BEM convention and therefore shouldn't happen.

   This was just a quick intro. Please invest your time into reading about BEM
   and into learning BEM in practice. It's not complex at all, it's rather small
   and very practical. Take your time to get to know tools around BEM, like the
   bem-cn library (https://www.npmjs.com/package/bem-cn) or a BEM linter for
   PostCSS (https://www.npmjs.com/package/postcss-bem-linter).

   Read more about BEM: https://en.bem.info
** CSS tips
*** Using calc and media queries to clamp values
    <https://fvsch.com/code/css-locks/>

    #+BEGIN_QUOTE
    A CSS lock is a Responsive Web Design technique that lets you transition
    smoothly between two values, depending on the current viewport size, rather
    than jump straight from one value to the other.
    #+END_QUOTE

    The article gives thorough overview of fitting the viewport width-specific
    font size (or any other property) into minimum and maximum boundaries while
    having it growing linearly within those boundaries.
** Browser performance
*** High Performance Browser Networking                                :book:
    <https://hpbn.co/>
** Browser security
* Product
* Delivery
** Manage static assets and CDN
   The frontend is considered static because it doesn't require any computation
   on the server side. It just gets delivered as is to the browser that
   requested it, and then it runs there. So a common practice to arrange
   delivery of the frontend code is to put it on CDN. As a frontend engineer,
   you need to have solid understanding of CDN basics and hands-on experience
   with the CDN provider of your choice. Cooperate with SRE or DevOps in your
   team to get to know how to manage assets on the CDN manually or in an
   automated way.
*** TODO AWS S3
*** TODO Azure
* Presentation
* Communication
** Meetings
*** "Reaching Peak Meeting Efficiency" by Steven Sinofsky
    https://medium.learningbyshipping.com/reaching-peak-meeting-efficiency-f8e47c93317a

    #+BEGIN_QUOTE
    In the course of building a company the most important tool you have to
    create a culture of shared values is communication and meetings are critical
    to communication.

    When you bring together a team of talented and diverse individuals, the only
    way they will come to operate as a team is by spending time talking,
    listening, and understanding the perspective individuals bring to contribute
    to a larger whole. Unless everyone hired shares the same background and
    experiences, there’s no way a group of people can converge to a
    high-performance team without meeting, sharing, and learning together. No
    amount of ping-pong, email, or shared docs can substitute for meeting.
    #+END_QUOTE

    A solid overview of meeting anti-patterns and ways to fix them. It's a long
    read that's worth putting on repeat and re-read every couple months.
* Documentation
** Know Markdown
   Knowing Markdown syntax is essential for modern web engineers. It's on Slack
   and StackOverflow, on Github and Gitlab, on Ghost and Gatsby, and knowing its
   syntax along with semantics makes you a better communicator.

   A few links:

   - Learn Markdown from its original reference:
     https://daringfireball.net/projects/markdown/syntax,
   - or from an awesome cheat-sheet:
     https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet.
** Add atomic examples to sequential tutorials
   <https://twitter.com/ryanflorence/status/999427816734113792>

   #+BEGIN_QUOTE
   Docs that act like a giant tutorial aren't as friendly as you might think. I
   want to hop in on a single topic but it assumes I've read all 30 pages of
   documentation before this one.

   Sequential tutorials/guides are great, but you gotta have atomic examples of
   an API too.
   #+END_QUOTE
* Vocabulary
** Expressiveness
   https://discourse.elm-lang.org/t/a-note-about-expressiveness/1286

   #+BEGIN_QUOTE
   It personally bugs me when people say “language X is less expressive than
   language Y” when it is almost always more accurate to say “that would be
   expressed differently in language X than in language Y and that makes me very
   angry”. It feels like a cheap way to make personal preferences sound like
   they are rooted in computer science and therefore more objective.
   #+END_QUOTE
